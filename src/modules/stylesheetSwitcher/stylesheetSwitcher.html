<div>
  <label for="{{id}}_select">{{label || ''}}</label>
  <select ref:selectElem id="{{id}}_select" on:change="setSelected(this.value)">
    {{#each stylesheets as sheet}}
    <option value="{{sheet.label}}">{{sheet.label}}</option>
    {{/each}}
  </select>
</div>

<script>
  // This is a test of the Svelte framework to evaluate how it can be integrated with other frameworks

  // Create a map of all the stylesheets, so we can enable one of them and disable the others
  let ssMap = new Map();

  function persistSelectedStyleSheet(keyName, value) {
    window.sessionStorage.setItem(keyName, value);
  }

  function retrieveSelectedStyleSheet(keyName) {
    return window.sessionStorage.getItem(keyName);
  }

  function findStyleRuleContainingText(styleBlocksArray, searchText) {
    const matching = styleBlocksArray
      .filter(sheet => (sheet.textContent || '').indexOf(searchText) > -1);

    return (matching.length === 1) ? matching : null; // We can match multiple <style> elements. handle this case inside setSelected()
  }

  export default {
    oncreate() {
      let persistedValue = retrieveSelectedStyleSheet(this.get('persistenceKeyName'));

      this.observe('stylesheets', (sheets) => {
        const styleBlocksArr = [].slice.call(document.querySelectorAll('style')); // Calculate this once

        ssMap.clear();
        sheets.forEach(sheet => {
          // v2.0 behaviour was all stylesheets were <link> elements.
          // v2.1 behaviour means that a stylesheet can also be in a <style> tag.
          if (sheet.linkHrefContains) {
            // <link> elements must be inside the <head> element. This also makes unit testing easier (as we can just mock document.head.querySelector)
            ssMap.set(sheet.label, document.head.querySelector(`link[rel="stylesheet"][href*="${sheet.linkHrefContains}"]`));
          } else if (sheet.styleElemContains) {
            ssMap.set(sheet.label, findStyleRuleContainingText(styleBlocksArr, sheet.styleElemContains));
          } else {
            throw new Error(`StyleSheetSwitcher.sheets."${sheet}" must contain a "linkHrefContains" property or a "styleElemContains" property which identifies the link/style element to control`);
          }
        });

        if (persistedValue && ssMap.has(persistedValue)) {
          this.setSelected(persistedValue);
        } else if (ssMap.size > 0) {
          // Set selected value to first value in the list (no need to update UI)
          this.setSelected(ssMap.keys().next().value, false);
        }
      });
    },
    data() {
      let obj = {
        stylesheets: [],      // Element is an object: {label: <string>, linkHrefContains: <string>}
        label: 'Stylesheet:',
        id: 'sss_' + (new Date().getTime()),
        persistenceKeyName: '__stylesheetSwitcher'
      };

      return obj;
    },
    methods: {
      setSelected(selectedKey, updateUI = true) {
        ssMap.forEach((styleSheetOrArray, key) => {
          // Handle either a single style or an array or styles:
          if (styleSheetOrArray && styleSheetOrArray.length) {
            styleSheetOrArray.forEach(style => style.disabled = (key !== selectedKey));
          } else {
            styleSheetOrArray.disabled = (key !== selectedKey);
          }
        });
        persistSelectedStyleSheet(this.get('persistenceKeyName'), selectedKey);

        let selectElem = this.refs.selectElem;

        this.fire('selectionChange', {value: selectedKey});

        if (updateUI) {
          // Update the drop-down to match the initial value
          [...selectElem.options].forEach((option, index) => {
            if (option.value === selectedKey) {
              selectElem.selectedIndex = index;
            }
          });
        }
      },
      getSelected() {
        let selectElem = this.refs.selectElem;
        return selectElem.options[selectElem.selectedIndex].value;
      }
    }
  };
</script>
